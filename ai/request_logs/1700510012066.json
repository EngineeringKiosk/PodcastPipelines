{"prompt":"You will be provided a part of a transcript of a podcast episode.\nYour task is to find quotable sections that are short and can be used in shorts on instagram or youtube.\nThe sections should be funny or provocative.\nOutput the list of sections in german.","choices":[{"index":0,"message":{"role":"assistant","content":"- \"Wir haben jemanden aus der Oberpfalz, drei Kilometer von der Grenze von Franken. Da gibt es so einen richtigen Hass da unten.\"\n- \"Helene Fischer, weil unser Prototyp natürlich nicht lief.\"\n- \"Dein YouTube Channel, den du leider nach 10 oder 12 Episoden wieder eingestellt hast.\"\n- \"Deine esoterische Programmiersprachen.\"\n- \"Rust ist eine Art und Weise Programme zu schreiben, wie man sie vorher noch nicht hatte.\"\n- \"Speicher wird super verwaltet und ich muss wenig tun. Was macht jetzt Rust besser?\"\n- \"Rust ist eine Möglichkeit, Speicher auf andere Art zu verwalten, indem der Compiler zur Compile-Zeit erkennt, ob Speicher beispielsweise von mehreren Stellen mutable, also veränderlich, beschrieben wird.\"\n- \"Geschwindigkeit ist für viele ein Einstiegsfaktor.\"\n- \"Rust ist einfach eine stabilere Sprache.\"\n- \"Dieser Compiler ist so intelligent, der Compiler sagt mir Sachen, die habe ich sonst überhaupt noch nie mitbekommen bei irgendeiner anderen Sprache.\""},"finish_reason":"stop"},{"index":0,"message":{"role":"assistant","content":"- \"Der Borrow Checker ist ein Teil des Rust-Compilers, der eben genau für Ownership und Borrowing zuständig ist und diese Regeln überprüft. Diese Regeln gibt's in anderen Programmiersprachen auch, wie zum Beispiel in C++ mit Ray, Resource Allocation is Initialization. Aber das wird halt nicht vom compiler entforst also es wird vom programmierer verlangt dass eine gewisse disziplin herrscht im code und dieses prinzip einfach vom rust compiler ja vorausgesetzt also es gibt gar keine. Möglichkeit darum zu kommen gibt es eigentlich nur einen compiler.\"\n- \"Gibt es bei Rust nur einen? Es gibt einen Referenz-Compiler, Rust C. Der. Von Mozilla dann auch entwickelt wurde. Genau. Es gibt allerdings auch mittlerweile einen WebAssembly-basierten Compiler. Nennt sich CraneLift und der ist etwas langsamer zu Runtime, also zu Laufzeit, aber schneller zu Compile-Zeit.\"\n- \"Teilweise Flugzeugsoftware und Zugsoftware wird damit geschrieben. Da kannst du jetzt auch nicht sagen, dass sie als unsicher gilt. Die haben auch Features drin, wie zum Beispiel du hast einen Integer mit einem Wertebereich und wenn du dann ein Switch Case Statement hast, dann sagt der Compiler dir, hey, da ist ein Fall, der ist nicht berücksichtigt bei deinem Case, könnte zur Runtime krachen, compile ich den nicht. Also das, was du jetzt gerade so erwähnt, andere Sprachen liefern das ja auch mit.\"\n- \"Lisp hat natürlich auch einen Garbage Collector und eine Runtime und auch in dem Sinn Overhead, genau wie beispielsweise Java oder Kotlin auch.\"\n- \"Also Rust ist eine Multi-Paradigm-Programmiersprache. Man kann in Rust mehrere Paradigmen programmieren. Also so wie du heutzutage auch in Java funktionale Elemente drin hast.\"\n- \"Beziehungsweise wann ist das passiert? Es ist ja derzeit ein absoluter Hype mit Rust, sogar dass Andi als Go-Fanboy Rust kennt. Ist die Sprache alt? Ist die jetzt irgendwie zwei Jahre alt? Wann ist denn die so entstanden? Also Mozilla ist eine Firma, die ist bekannt für eigentlich zwei große Projekte, würde ich behaupten. Zum einen"},"finish_reason":"length"},{"index":0,"message":{"role":"assistant","content":"- \"Muss ich vielleicht Over-Provisioning machen?\"\n- \"Das ist der Unterschied zwischen Java Runtime Performance und Rust Runtime Performance.\"\n- \"Java ist natürlich was, ich sag jetzt mal zum Beispiel Arbeitsspeicher angeht relativ durstig.\"\n- \"Der Klassiker ist zum Beispiel aus der C- oder C++-Ecke Leute, die Rust lernen, die haben Probleme mit diesem Ownership-Modell.\"\n- \"Also bleiben wir vielleicht gleich mal beim Speicherkonzept, wie funktioniert dieses ominöse Borrowing Speicherkonzept, was die Welt verändert?\"\n- \"Und man kann von oben was nehmen oder man kann irgendwas drauflegen. Das macht den schnell, aber das macht den auch relativ trivial.\"\n- \"Rust ist halt in der Beziehung relativ explizit im Vergleich zu anderen Sprachen.\"\n- \"Das heißt, man hat schon intuitiv das Gefühl, da sind mehrere Ebenen der Indirektion zwischendrin, bis dass ich darauf zugreifen kann.\"\n- \"Jetzt fragt man sich natürlich, warum. Moment, was heißt Ownership?\"\n- \"Es gibt einen Besitzer dieses Speicherbereichs. Der Datei. Es gibt einen Besitzer dieser Datei, genau.\""},"finish_reason":"stop"},{"index":0,"message":{"role":"assistant","content":"\"Es gibt noch ein zusätzliches Konzept, das nennt sich Borrowing.\"\n\"Ich kann ein Borrow zum Beispiel an verschiedene Leute geben.\"\n\"Rust ist extrem explizit und will, dass schlimme Dinge nicht passieren.\"\n\"Dieses Drop wird automatisch ausgeführt und wird eingefügt an die Stelle, wo die Funktion beendet.\"\n\"Smart-Pointer haben die interessante Eigenschaft, dass sie etwas smarter sind als normale Pointer.\"\n\"Warum hat man überhaupt globale Daten?\"\n\"Also, in Rust gibt es auch atomics, das heißt da macht das der die cpu für dich und entscheidet dann dass du atomar zum Beispiel eine zahl erhöhst also ein increment machst.\"\n\"Genau also hilft der Compiler dir und sagt nee ist nicht oder weil ich meine du setzt ja schon das Ownership und Borrowchecker Modell komplett außer Kraft in irgendeiner Art und Weise.\"\n\"Das heißt, dieses Modell vereinfacht mir dann das parallele Arbeiten genauso?\"\n\"Dann musst du dir überlegen, wie du das machst.\""},"finish_reason":"stop"},{"index":0,"message":{"role":"assistant","content":"- Das klassische Entwicklermodell ist ja eigentlich, du programmierst was, compilest das, und du kriegst irgendwie eine komische kryptische Errormeldung.\n- Auf jeden Fall kopierst du dann die erste Stackoverflow-Antwort und jetzt die erste Chat-GPT-Antwort und dann geht's einfach weiter.\n- Ja, aber schon noch das, was vielleicht ein Mensch verstehen kann. Statistisch berechnen, oder eher statistisch einfach durchkalkuliert, ja genau.\n- Und ich denke, man wird da in der Beziehung auch vom Compiler ein bisschen an die Hand genommen und besser geschult.\n- Es wäre schon sehr schön gewesen, so einen Compiler früher zu haben.\n- Fundamental ist alles, was man am Computer macht, unsafe. Das ist einfach eine Realität des Lebens.\n- Man kann auch den Weg gehen und sagen, eigentlich ist alles schön der heile Welt und ich kümmere mich gar nicht darum, sondern ich gehe mal davon aus, alles ist safe. Und dann läuft man halt einfach zur Runtime in gewisse Probleme wie bei Python oder PHP.\n- Und die Art und Weise, wie man Rust programmiert, ist eigentlich, dass man sehr, sehr wenig Unsafe programmiert.\n- Leider muss man da sagen, Go ist da unglaublich stark, bereits über zehn Jahre.\n- Aber ich meine, auch mit Go 2.0 sind jetzt die ersten Blogposts rausgekommen und sie überlegen auch, in 2.0 keine Rückwärtskompatibilität zu brechen.\n- Aber mich würde mal interessieren, wie macht Rust das? Wie sorgt Rust dafür, zum Beispiel neue Features wie Async, das Async-Keyword haben sie vor anderthalb Jahren eingeführt oder ähnliches?"},"finish_reason":"stop"},{"index":0,"message":{"role":"assistant","content":"- \"Da geht es Richtung Auch wieder Ownership und Borrowing und Lifetimes, Non-Lexical Lifetimes. Da hat man einfach festgestellt, okay, wir können das nicht einführen, wenn wir da kein Bracking Change machen.\"\n- \"Angenommen, ich schreibe jetzt Async und das ist aber jetzt ein Keyword in der neuesten Version, dann ist das ein Bricking Change.\"\n- \"Am Anfang nannte man das Epochs, mittlerweile heißt es Editions. Und die Idee von einer Edition ist, dass die im Compiler in der Standard Library eingebunden ist.\"\n- \"Jetzt kann man natürlich auch fragen, muss man dann für jeden Breaking Change eine neue Edition machen? Das wäre ja fatal.\"\n- \"Das ist ein interessantes Konzept.\"\n- \"Und da gibt es ein cooles Konzept, das nennt sich Crater.\"\n- \"Und dieses Tooling ist Open Source.\"\n- \"Also sehr pragmatischer Ansatz eigentlich.\"\n- \"Also immer wenn wir von datengetriebenen Entscheidungen sprechen, Du kannst zwar immer noch von einer opinionated Implementierung sprechen, aber es ist halt schon sehr, sehr datenbasiert.\"\n- \"Die schauen sich das Ecosystem an und schauen, wie werden Features genutzt, zum Beispiel jetzt Logging-Libraries oder damals das Package-Management und versuchen dann, ich sag mal, die beste Lösung, das beste Design in die Sprache zu überführen.\"\n- \"Ja, ja, entweder Open Source oder man wird nicht berücksichtigt.\"\n- \"Die checken nicht nur, ob eine Änderung irgendwelchen Impact auf Crates hat, sondern wenn die feststellen, das sind auch Crates, die davon betroffen sind, dann gehen die her, kontaktieren die Maintainer und senden den Pull-Request und sagen, es tut uns leid, wir müssen hier eine Soft-Breaking-Change machen.\"\n- \"Und damit ist es fine.\"\n- \"Wie schafft Rust dieses marketing dass alle leute irgendwie über rast sprechen und ich kenne ganz wenig leute die wirklich rast mal probiert haben?\"\n- \"Ja, der erste Anstoß ist natürlich immer, ich will was Neues lernen, ich fühle mich eingeschränkt in meiner aktuellen Umgebung, also sowas bei mir z"},"finish_reason":"length"},{"index":0,"message":{"role":"assistant","content":"- Die Compiler-Meldungen sind manchmal so kryptisch, dass du keine Ahnung hast und ewig rumprobieren musst, um das Problem zu verstehen.\n- Rust wird nicht das neue JavaScript werden, es wird eher C++ Konkurrenz machen für neue Projekte.\n- Rust hat 3,7 Millionen Nutzer und 600.000 davon allein in den letzten sechs Monaten, also ein beachtliches Wachstum.\n- Rust könnte einen großen Teil des Marktes übernehmen, vor allem in Bereichen wie Gaming, Real-Time, Automotive und Embedded.\n- Das Async-Ecosystem in Rust ist noch sehr jung und verändert die Art und Weise, wie man Rust programmiert.\n- Rust ist wie eine andere Sprache, ähnlich wie Spanisch und Portugiesisch.\n- Bei der Nutzung von Async Rust muss man sich in das Ecosystem mit Libraries wie Tokio einkaufen.\n- Das Async-Ecosystem ist noch relativ neu und es gibt noch viele Dinge, die nicht 1.0 erreicht haben.\n- Rust hat ein stabiles Ecosystem mit vielen Libraries, aber es erfordert eine gewisse Vorsicht bei den Dependencies.\n- Rust hat unglaublich schnelle Compiletimes, aber bei großen Applikationen kann es zu längeren Kompilierzeiten kommen.\n- Der Rust-Compiler wird jedes Jahr etwa 10% schneller.\n- Rust ist schneller als Go, da viele Dinge in Rust zur Compile-Zeit erledigt werden."},"finish_reason":"stop"},{"index":0,"message":{"role":"assistant","content":"- \"In Rust wird beispielsweise für jeden Input, den eine generische Funktion hat, eine konkrete Version zur Compile-Zeit gebaut. Und das kostet natürlich Zeit.\"\n- \"LLVM ist ein Backend, was nicht das schnellste ist. Go hat das eigene Backend, die haben selber eins geschrieben und das ist auch in Go geschrieben mittlerweile, war früher glaube ich nicht in Go.\"\n- \"Ich würde auch sagen, wenn du jetzt keine multimillionen Lines-of-Code Rust-Application hast, dann spielen auch auf CI-Systemen die Compiletines nicht wirklich eine Rolle.\"\n- \"Rust hätte da auch noch Defizite.\"\n- \"Es gibt dieses Idomatic Rust Repository, was du angesprochen hast, wo ich solche Ressourcen eben sammle. Da kann man mal nachschauen.\"\n- \"Ein klassisches Pattern ist das Builder-Pattern, weil in Rust gibt es keine Funktionen mit einer variablen Anzahl von Variablen.\"\n- \"Objektorientierung wird grundsätzlich unterstützt. Aber ist jetzt keine Hardcore-Objektorientierung mit Polymorphie und die ganzen Geschichten?\"\n- \"Traits sind Eigenschaften, die Dinge haben können oder auch nicht.\"\n- \"Funktionsüberladung gibt's. Es gibt zum Beispiel auch die Möglichkeit Operatoren zu überladen.\"\n- \"Aber zum Beispiel Funktionen überladen oder solche Dinge, das funktioniert nicht.\"\n- \"Modelle oder vielleicht auch Patterns, wenn man die so nennen will, die in Rust-Gang und Geber sind.\"\n- \"Insofern ist nur ein Beweis mehr, dass Vererbung gar nicht mehr so das Nonplusultra ist, wie es früher mal war, meiner Meinung nach.\"\n- \"Definitiv, bitte subscriben und die kleine Glocke und läuten und alles.\"\n- \"Wenn man aus dem Web-Bereich kommt, würde ich sagen, eine Ressource, die man sich anschauen kann, ist von einem Freund von mir, Luca Palmieri, Zero to Production in Rust.\"\n- \"Vielen, vielen Dank für alle Informationen.\"\n- \"Jetzt bin ich doch wieder ein bisschen motiviert, Rust irgendwie zu lernen.\"\n- \"Gute investierte Zeit. Vielen lieben Dank, Matthias.\"\n- \""},"finish_reason":"length"},{"index":0,"message":{"role":"assistant","content":"- \"Ihr wolltet Ende machen. Also, muss ich schon Ende machen?\"\n- \"Der Y-Rust-Artikel ist nicht zum Lernen. Ich hätte schon noch eine.\"\n- \"Meine Kamera ist abgeschaltet. Schade.\"\n- \"Nur Amateure. Wir haben echt technische Probleme heute.\"\n- \"Der Kollege aus diesem kleinen Land namens Austria ist das Problem. Ja, ja. Sehe ich auch so.\"\n- \"Die hat doch einen USB-Anschluss. Hätte man doch eigentlich auch an Strom anschließen können.\"\n- \"Er ist sich nicht sicher, ob es funktioniert oder ob es eine Datenübertragung ist. Das ist ein Fehlerpunkt.\"\n- \"Mir ist das ein bisschen peinlich. Schon wieder live. Live von der Position.\"\n- \"Wir haben einen Aufnahmetermin im Jahr. Wir haben zwei Gäste an diesem Tag und es fällt hier eins nach dem anderen aus.\"\n- \"Es hat nicht durchgehalten, weil du so viel redest. Der ist auf eine Stunde zehn genau gedeimt, der Akku.\""},"finish_reason":"stop"}],"results":[{"status":"fulfilled","value":{"id":"chatcmpl-8N4RllcNPQNLhC1HRXndQayTqEdv9","object":"chat.completion","created":1700509329,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"message":{"role":"assistant","content":"- \"Wir haben jemanden aus der Oberpfalz, drei Kilometer von der Grenze von Franken. Da gibt es so einen richtigen Hass da unten.\"\n- \"Helene Fischer, weil unser Prototyp natürlich nicht lief.\"\n- \"Dein YouTube Channel, den du leider nach 10 oder 12 Episoden wieder eingestellt hast.\"\n- \"Deine esoterische Programmiersprachen.\"\n- \"Rust ist eine Art und Weise Programme zu schreiben, wie man sie vorher noch nicht hatte.\"\n- \"Speicher wird super verwaltet und ich muss wenig tun. Was macht jetzt Rust besser?\"\n- \"Rust ist eine Möglichkeit, Speicher auf andere Art zu verwalten, indem der Compiler zur Compile-Zeit erkennt, ob Speicher beispielsweise von mehreren Stellen mutable, also veränderlich, beschrieben wird.\"\n- \"Geschwindigkeit ist für viele ein Einstiegsfaktor.\"\n- \"Rust ist einfach eine stabilere Sprache.\"\n- \"Dieser Compiler ist so intelligent, der Compiler sagt mir Sachen, die habe ich sonst überhaupt noch nie mitbekommen bei irgendeiner anderen Sprache.\""},"finish_reason":"stop"}],"usage":{"prompt_tokens":2387,"completion_tokens":249,"total_tokens":2636}}},{"status":"fulfilled","value":{"id":"chatcmpl-8N4bSt6Dp2vliQNiWUViTSRrQCXk2","object":"chat.completion","created":1700509930,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"message":{"role":"assistant","content":"- \"Der Borrow Checker ist ein Teil des Rust-Compilers, der eben genau für Ownership und Borrowing zuständig ist und diese Regeln überprüft. Diese Regeln gibt's in anderen Programmiersprachen auch, wie zum Beispiel in C++ mit Ray, Resource Allocation is Initialization. Aber das wird halt nicht vom compiler entforst also es wird vom programmierer verlangt dass eine gewisse disziplin herrscht im code und dieses prinzip einfach vom rust compiler ja vorausgesetzt also es gibt gar keine. Möglichkeit darum zu kommen gibt es eigentlich nur einen compiler.\"\n- \"Gibt es bei Rust nur einen? Es gibt einen Referenz-Compiler, Rust C. Der. Von Mozilla dann auch entwickelt wurde. Genau. Es gibt allerdings auch mittlerweile einen WebAssembly-basierten Compiler. Nennt sich CraneLift und der ist etwas langsamer zu Runtime, also zu Laufzeit, aber schneller zu Compile-Zeit.\"\n- \"Teilweise Flugzeugsoftware und Zugsoftware wird damit geschrieben. Da kannst du jetzt auch nicht sagen, dass sie als unsicher gilt. Die haben auch Features drin, wie zum Beispiel du hast einen Integer mit einem Wertebereich und wenn du dann ein Switch Case Statement hast, dann sagt der Compiler dir, hey, da ist ein Fall, der ist nicht berücksichtigt bei deinem Case, könnte zur Runtime krachen, compile ich den nicht. Also das, was du jetzt gerade so erwähnt, andere Sprachen liefern das ja auch mit.\"\n- \"Lisp hat natürlich auch einen Garbage Collector und eine Runtime und auch in dem Sinn Overhead, genau wie beispielsweise Java oder Kotlin auch.\"\n- \"Also Rust ist eine Multi-Paradigm-Programmiersprache. Man kann in Rust mehrere Paradigmen programmieren. Also so wie du heutzutage auch in Java funktionale Elemente drin hast.\"\n- \"Beziehungsweise wann ist das passiert? Es ist ja derzeit ein absoluter Hype mit Rust, sogar dass Andi als Go-Fanboy Rust kennt. Ist die Sprache alt? Ist die jetzt irgendwie zwei Jahre alt? Wann ist denn die so entstanden? Also Mozilla ist eine Firma, die ist bekannt für eigentlich zwei große Projekte, würde ich behaupten. Zum einen"},"finish_reason":"length"}],"usage":{"prompt_tokens":2393,"completion_tokens":500,"total_tokens":2893}}},{"status":"fulfilled","value":{"id":"chatcmpl-8N4RlXBgOriUtcDnHqwW0BDw8H23q","object":"chat.completion","created":1700509329,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"message":{"role":"assistant","content":"- \"Muss ich vielleicht Over-Provisioning machen?\"\n- \"Das ist der Unterschied zwischen Java Runtime Performance und Rust Runtime Performance.\"\n- \"Java ist natürlich was, ich sag jetzt mal zum Beispiel Arbeitsspeicher angeht relativ durstig.\"\n- \"Der Klassiker ist zum Beispiel aus der C- oder C++-Ecke Leute, die Rust lernen, die haben Probleme mit diesem Ownership-Modell.\"\n- \"Also bleiben wir vielleicht gleich mal beim Speicherkonzept, wie funktioniert dieses ominöse Borrowing Speicherkonzept, was die Welt verändert?\"\n- \"Und man kann von oben was nehmen oder man kann irgendwas drauflegen. Das macht den schnell, aber das macht den auch relativ trivial.\"\n- \"Rust ist halt in der Beziehung relativ explizit im Vergleich zu anderen Sprachen.\"\n- \"Das heißt, man hat schon intuitiv das Gefühl, da sind mehrere Ebenen der Indirektion zwischendrin, bis dass ich darauf zugreifen kann.\"\n- \"Jetzt fragt man sich natürlich, warum. Moment, was heißt Ownership?\"\n- \"Es gibt einen Besitzer dieses Speicherbereichs. Der Datei. Es gibt einen Besitzer dieser Datei, genau.\""},"finish_reason":"stop"}],"usage":{"prompt_tokens":2377,"completion_tokens":269,"total_tokens":2646}}},{"status":"fulfilled","value":{"id":"chatcmpl-8N4bSZEC9QvRMzRaTn3kxWNwdMUcQ","object":"chat.completion","created":1700509930,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"message":{"role":"assistant","content":"\"Es gibt noch ein zusätzliches Konzept, das nennt sich Borrowing.\"\n\"Ich kann ein Borrow zum Beispiel an verschiedene Leute geben.\"\n\"Rust ist extrem explizit und will, dass schlimme Dinge nicht passieren.\"\n\"Dieses Drop wird automatisch ausgeführt und wird eingefügt an die Stelle, wo die Funktion beendet.\"\n\"Smart-Pointer haben die interessante Eigenschaft, dass sie etwas smarter sind als normale Pointer.\"\n\"Warum hat man überhaupt globale Daten?\"\n\"Also, in Rust gibt es auch atomics, das heißt da macht das der die cpu für dich und entscheidet dann dass du atomar zum Beispiel eine zahl erhöhst also ein increment machst.\"\n\"Genau also hilft der Compiler dir und sagt nee ist nicht oder weil ich meine du setzt ja schon das Ownership und Borrowchecker Modell komplett außer Kraft in irgendeiner Art und Weise.\"\n\"Das heißt, dieses Modell vereinfacht mir dann das parallele Arbeiten genauso?\"\n\"Dann musst du dir überlegen, wie du das machst.\""},"finish_reason":"stop"}],"usage":{"prompt_tokens":2304,"completion_tokens":237,"total_tokens":2541}}},{"status":"fulfilled","value":{"id":"chatcmpl-8N4RlNKcdPaCeVpBZ1x1jqAmhAPyj","object":"chat.completion","created":1700509329,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"message":{"role":"assistant","content":"- Das klassische Entwicklermodell ist ja eigentlich, du programmierst was, compilest das, und du kriegst irgendwie eine komische kryptische Errormeldung.\n- Auf jeden Fall kopierst du dann die erste Stackoverflow-Antwort und jetzt die erste Chat-GPT-Antwort und dann geht's einfach weiter.\n- Ja, aber schon noch das, was vielleicht ein Mensch verstehen kann. Statistisch berechnen, oder eher statistisch einfach durchkalkuliert, ja genau.\n- Und ich denke, man wird da in der Beziehung auch vom Compiler ein bisschen an die Hand genommen und besser geschult.\n- Es wäre schon sehr schön gewesen, so einen Compiler früher zu haben.\n- Fundamental ist alles, was man am Computer macht, unsafe. Das ist einfach eine Realität des Lebens.\n- Man kann auch den Weg gehen und sagen, eigentlich ist alles schön der heile Welt und ich kümmere mich gar nicht darum, sondern ich gehe mal davon aus, alles ist safe. Und dann läuft man halt einfach zur Runtime in gewisse Probleme wie bei Python oder PHP.\n- Und die Art und Weise, wie man Rust programmiert, ist eigentlich, dass man sehr, sehr wenig Unsafe programmiert.\n- Leider muss man da sagen, Go ist da unglaublich stark, bereits über zehn Jahre.\n- Aber ich meine, auch mit Go 2.0 sind jetzt die ersten Blogposts rausgekommen und sie überlegen auch, in 2.0 keine Rückwärtskompatibilität zu brechen.\n- Aber mich würde mal interessieren, wie macht Rust das? Wie sorgt Rust dafür, zum Beispiel neue Features wie Async, das Async-Keyword haben sie vor anderthalb Jahren eingeführt oder ähnliches?"},"finish_reason":"stop"}],"usage":{"prompt_tokens":2389,"completion_tokens":387,"total_tokens":2776}}},{"status":"fulfilled","value":{"id":"chatcmpl-8N4Rl2hx5jOcg1ikENhBdEQobXxpC","object":"chat.completion","created":1700509329,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"message":{"role":"assistant","content":"- \"Da geht es Richtung Auch wieder Ownership und Borrowing und Lifetimes, Non-Lexical Lifetimes. Da hat man einfach festgestellt, okay, wir können das nicht einführen, wenn wir da kein Bracking Change machen.\"\n- \"Angenommen, ich schreibe jetzt Async und das ist aber jetzt ein Keyword in der neuesten Version, dann ist das ein Bricking Change.\"\n- \"Am Anfang nannte man das Epochs, mittlerweile heißt es Editions. Und die Idee von einer Edition ist, dass die im Compiler in der Standard Library eingebunden ist.\"\n- \"Jetzt kann man natürlich auch fragen, muss man dann für jeden Breaking Change eine neue Edition machen? Das wäre ja fatal.\"\n- \"Das ist ein interessantes Konzept.\"\n- \"Und da gibt es ein cooles Konzept, das nennt sich Crater.\"\n- \"Und dieses Tooling ist Open Source.\"\n- \"Also sehr pragmatischer Ansatz eigentlich.\"\n- \"Also immer wenn wir von datengetriebenen Entscheidungen sprechen, Du kannst zwar immer noch von einer opinionated Implementierung sprechen, aber es ist halt schon sehr, sehr datenbasiert.\"\n- \"Die schauen sich das Ecosystem an und schauen, wie werden Features genutzt, zum Beispiel jetzt Logging-Libraries oder damals das Package-Management und versuchen dann, ich sag mal, die beste Lösung, das beste Design in die Sprache zu überführen.\"\n- \"Ja, ja, entweder Open Source oder man wird nicht berücksichtigt.\"\n- \"Die checken nicht nur, ob eine Änderung irgendwelchen Impact auf Crates hat, sondern wenn die feststellen, das sind auch Crates, die davon betroffen sind, dann gehen die her, kontaktieren die Maintainer und senden den Pull-Request und sagen, es tut uns leid, wir müssen hier eine Soft-Breaking-Change machen.\"\n- \"Und damit ist es fine.\"\n- \"Wie schafft Rust dieses marketing dass alle leute irgendwie über rast sprechen und ich kenne ganz wenig leute die wirklich rast mal probiert haben?\"\n- \"Ja, der erste Anstoß ist natürlich immer, ich will was Neues lernen, ich fühle mich eingeschränkt in meiner aktuellen Umgebung, also sowas bei mir z"},"finish_reason":"length"}],"usage":{"prompt_tokens":2336,"completion_tokens":500,"total_tokens":2836}}},{"status":"fulfilled","value":{"id":"chatcmpl-8N4Rl1EnbrWyZP1R0AHbOgYqyj21p","object":"chat.completion","created":1700509329,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"message":{"role":"assistant","content":"- Die Compiler-Meldungen sind manchmal so kryptisch, dass du keine Ahnung hast und ewig rumprobieren musst, um das Problem zu verstehen.\n- Rust wird nicht das neue JavaScript werden, es wird eher C++ Konkurrenz machen für neue Projekte.\n- Rust hat 3,7 Millionen Nutzer und 600.000 davon allein in den letzten sechs Monaten, also ein beachtliches Wachstum.\n- Rust könnte einen großen Teil des Marktes übernehmen, vor allem in Bereichen wie Gaming, Real-Time, Automotive und Embedded.\n- Das Async-Ecosystem in Rust ist noch sehr jung und verändert die Art und Weise, wie man Rust programmiert.\n- Rust ist wie eine andere Sprache, ähnlich wie Spanisch und Portugiesisch.\n- Bei der Nutzung von Async Rust muss man sich in das Ecosystem mit Libraries wie Tokio einkaufen.\n- Das Async-Ecosystem ist noch relativ neu und es gibt noch viele Dinge, die nicht 1.0 erreicht haben.\n- Rust hat ein stabiles Ecosystem mit vielen Libraries, aber es erfordert eine gewisse Vorsicht bei den Dependencies.\n- Rust hat unglaublich schnelle Compiletimes, aber bei großen Applikationen kann es zu längeren Kompilierzeiten kommen.\n- Der Rust-Compiler wird jedes Jahr etwa 10% schneller.\n- Rust ist schneller als Go, da viele Dinge in Rust zur Compile-Zeit erledigt werden."},"finish_reason":"stop"}],"usage":{"prompt_tokens":2355,"completion_tokens":321,"total_tokens":2676}}},{"status":"fulfilled","value":{"id":"chatcmpl-8N4RlknrBkZZBOLTcLda67JuCT76h","object":"chat.completion","created":1700509329,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"message":{"role":"assistant","content":"- \"In Rust wird beispielsweise für jeden Input, den eine generische Funktion hat, eine konkrete Version zur Compile-Zeit gebaut. Und das kostet natürlich Zeit.\"\n- \"LLVM ist ein Backend, was nicht das schnellste ist. Go hat das eigene Backend, die haben selber eins geschrieben und das ist auch in Go geschrieben mittlerweile, war früher glaube ich nicht in Go.\"\n- \"Ich würde auch sagen, wenn du jetzt keine multimillionen Lines-of-Code Rust-Application hast, dann spielen auch auf CI-Systemen die Compiletines nicht wirklich eine Rolle.\"\n- \"Rust hätte da auch noch Defizite.\"\n- \"Es gibt dieses Idomatic Rust Repository, was du angesprochen hast, wo ich solche Ressourcen eben sammle. Da kann man mal nachschauen.\"\n- \"Ein klassisches Pattern ist das Builder-Pattern, weil in Rust gibt es keine Funktionen mit einer variablen Anzahl von Variablen.\"\n- \"Objektorientierung wird grundsätzlich unterstützt. Aber ist jetzt keine Hardcore-Objektorientierung mit Polymorphie und die ganzen Geschichten?\"\n- \"Traits sind Eigenschaften, die Dinge haben können oder auch nicht.\"\n- \"Funktionsüberladung gibt's. Es gibt zum Beispiel auch die Möglichkeit Operatoren zu überladen.\"\n- \"Aber zum Beispiel Funktionen überladen oder solche Dinge, das funktioniert nicht.\"\n- \"Modelle oder vielleicht auch Patterns, wenn man die so nennen will, die in Rust-Gang und Geber sind.\"\n- \"Insofern ist nur ein Beweis mehr, dass Vererbung gar nicht mehr so das Nonplusultra ist, wie es früher mal war, meiner Meinung nach.\"\n- \"Definitiv, bitte subscriben und die kleine Glocke und läuten und alles.\"\n- \"Wenn man aus dem Web-Bereich kommt, würde ich sagen, eine Ressource, die man sich anschauen kann, ist von einem Freund von mir, Luca Palmieri, Zero to Production in Rust.\"\n- \"Vielen, vielen Dank für alle Informationen.\"\n- \"Jetzt bin ich doch wieder ein bisschen motiviert, Rust irgendwie zu lernen.\"\n- \"Gute investierte Zeit. Vielen lieben Dank, Matthias.\"\n- \""},"finish_reason":"length"}],"usage":{"prompt_tokens":2434,"completion_tokens":500,"total_tokens":2934}}},{"status":"fulfilled","value":{"id":"chatcmpl-8N4RoBWC8qY3WBG4C3LvzJSR3K5lC","object":"chat.completion","created":1700509332,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"message":{"role":"assistant","content":"- \"Ihr wolltet Ende machen. Also, muss ich schon Ende machen?\"\n- \"Der Y-Rust-Artikel ist nicht zum Lernen. Ich hätte schon noch eine.\"\n- \"Meine Kamera ist abgeschaltet. Schade.\"\n- \"Nur Amateure. Wir haben echt technische Probleme heute.\"\n- \"Der Kollege aus diesem kleinen Land namens Austria ist das Problem. Ja, ja. Sehe ich auch so.\"\n- \"Die hat doch einen USB-Anschluss. Hätte man doch eigentlich auch an Strom anschließen können.\"\n- \"Er ist sich nicht sicher, ob es funktioniert oder ob es eine Datenübertragung ist. Das ist ein Fehlerpunkt.\"\n- \"Mir ist das ein bisschen peinlich. Schon wieder live. Live von der Position.\"\n- \"Wir haben einen Aufnahmetermin im Jahr. Wir haben zwei Gäste an diesem Tag und es fällt hier eins nach dem anderen aus.\"\n- \"Es hat nicht durchgehalten, weil du so viel redest. Der ist auf eine Stunde zehn genau gedeimt, der Akku.\""},"finish_reason":"stop"}],"usage":{"prompt_tokens":726,"completion_tokens":238,"total_tokens":964}}}]}